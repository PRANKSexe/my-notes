## PWN 101 — Buffer Overflow

==I==n the first challenge if we use the pwntools function’s checksec, as in the example below, we can see that there are lots of protections to the binary.

![](https://miro.medium.com/v2/resize:fit:654/1*BhazmEHIHVdGDD82VcmQxw.png)

It seems to be difficult but, if we look closely on the code with ghidra, we can see that we only need to overflow the code that, is very simple because of the gets, which is a dangerous, that it does not count the bound of the array. Below there is a very simple script to solve it.
![[Pasted image 20250711235849.png]]
And here is the result when we connect to the server with the VPN of TryHackMe.

![](https://miro.medium.com/v2/resize:fit:700/1*MTJvfFZNl6RIqI7ORgASVA.png)
## PWN 102 — Modify Variable’s value

In this second challenge the binary says that it wants ‘bad food’, but what does it means with bad food? As we did in the first challenge we can try to check for any sort of protection with checksec.

![](https://miro.medium.com/v2/resize:fit:639/1*bmwxvuC3UTpVG749ws6tPA.png)

Again we can see that there are a lot of protections so, before we start to complicate our life, let’s take a look to the code with Ghidra, that let us to see a demo of the code in c.

![](https://miro.medium.com/v2/resize:fit:700/1*6_rt7I17N9BPo6QG9KDo3g.png)

With this code we can see that the program check if “local_c” and “local_10", that we will call var1 and var2, are equal to “0xc0d3” and “ 0xc0ff33”. What we can do to change their values?

We can overflow the buffer (that’s easy because this scanf doesn’t count the number of characters) but instead to overwrite the Instruction Pointer we have to simply write a little more over the buffer where there are all the variables that are used on the program.

Remember this is true, because the variables are declared on the stack and not on the heap.

Here is a short script to solve the challenge.
![[Pasted image 20250712000034.png]]
Below the result.

![](https://miro.medium.com/v2/resize:fit:700/1*7gvzvWkAMeTyMXWgFHyMyw.png)

## PWN 103 — Return to Win


![](https://miro.medium.com/v2/resize:fit:494/1*HJCd8UPrdjTkypqyBIHeJA.png)

![](https://miro.medium.com/v2/resize:fit:633/1*pisc02GKSDsYRCfQFyjIMg.png)

The title speaks for itself, because we have to make a buffer overflow to change the Instruction pointer that it will point to the win function. Before starting we must have in mind the idea of a buffer overflow. It means that we want to write over the buffer to reach the Base pointer that is before the Instruction pointer. And then we overwrite it with the right function.

After this premise we just have to find the address of the win function with GDB or whatever you want.

![](https://miro.medium.com/v2/resize:fit:621/1*GiLfe0aTGJEwYaCSfTo68w.png)

We have found a type of win function, that in this case is called admins_only, where we can see a system function that call a bash for us. Now we have all that we need to complete this challenge, so let’s write a script.
![[Pasted image 20250712200413.png]]
## PWN 104 — Return to Shellcode

![](https://miro.medium.com/v2/resize:fit:700/1*nFBDAp9Zzaec-yjTqcdRng.png)

![](https://miro.medium.com/v2/resize:fit:630/1*5UhHwe4P3tYKGLSwrA0lyA.png)

This is the fourth challenge of this room, and we can see that there is a buffer overflow, a given address, and all the protections disabled (except for the RELRO which we will talk about later). As the title says we have to do a buffer overflow to execute a shellcode that will call a bash, with system, because of the setuid permission which is used to execute a program as a root. Before we start, as always, let’s see if our forecasts are true with Ghidra.

![](https://miro.medium.com/v2/resize:fit:581/1*2b65O0W1meebXL1f1UZJrw.png)

200, instead of 80 in the read

Yeah we were right, because there is a read that accept an amount of number equal to 200, when the buffer is 80 large. After that we can see that the address given is the start of our buffer from the stack, because we have a %p that return an address from the stack. This is very helpful because, our plan is to write into the buffer the shellcode to execute and then change the RIP, which it will point another time into our buffer, where now there is the shellcode that will be executed.

![[Pasted image 20250712195847.png]]