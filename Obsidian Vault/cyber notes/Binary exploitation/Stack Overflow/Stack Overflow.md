# 📚 Stack: Full Notes with Working Flow & Diagram

---

## 📦 What Is the Stack?

The **stack** is a **region of memory** used for:

- **Function call management**
    
- **Local variables**
    
- **Return addresses**
    
- **Control flow**
    

It works as a **Last-In, First-Out (LIFO)** structure:

> The last thing pushed onto the stack is the first thing popped off.

---

## 🧠 Key Concepts

| Concept             | Description                                                            |
| ------------------- | ---------------------------------------------------------------------- |
| **Stack Frame**     | Memory section for each function call (arguments, locals, return addr) |
| **ESP/RSP**         | Stack Pointer: Points to the top of the stack                          |
| **EBP/RBP**         | Base Pointer: Marks the start of the current stack frame               |
| **Return Address**  | Where to go back after function call ends                              |
| **Local Variables** | Temporary values only visible within the function                      |
|                     |                                                                        |

---

## 📐 Stack Growth Direction

On **x86/x64**, the stack:

- Grows **downward** (towards lower memory addresses)
    
- Is automatically allocated/deallocated with each function call
    

---

## 🔁 Stack Working Flow (Step-by-Step)

### 🧩 When a Function Is Called:

1. Caller pushes **function arguments**
    
2. CPU pushes **return address** (where to return after function)
    
3. Stack pointer (ESP/RSP) is adjusted
    
4. Function prologue runs:
    
    - Save caller’s base pointer (`push ebp`)
        
    - Set new base pointer (`mov ebp, esp`)
        
5. Allocate space for **local variables**
    

### 🔁 When Function Returns:

1. Function epilogue restores stack frame
    
    - `mov esp, ebp`
        
    - `pop ebp`
        
2. CPU pops **return address**
    
3. Execution jumps back to caller
    

---

## 📊 Stack Diagram: Function Call (C Example)

### 🔤 C Code:

c
**void func(int x) {**
    **int a = 10;**
    **int b = 20;**
**}**

**int main() {**
    **func(5);**
    **return 0;**
**}**

### 🧭 Stack Layout (x86 - simplified)

` b = 20                 |  ← Local variable (func) ----------------------------- |   a = 10                 |  ← Local variable (func) ----------------------------- |   saved EBP             |  ← Base pointer from main() ----------------------------- |   return address        |  ← To return to main() ----------------------------- |   argument x = 5        |  ← Argument to func() ----------------------------- |   ... main() stack ...  | -----------------------------`

---

## 🔍 Registers Involved

|Register|Role|
|---|---|
|`ESP/RSP`|Stack Pointer (top of the stack)|
|`EBP/RBP`|Base Pointer (start of current frame)|
|`EIP/RIP`|Instruction Pointer (next instruction)|

---

## 🧠 Real Example in Assembly

asm
**func:**
    **push ebp            ; Save base pointer**
    **mov ebp, esp        ; New base pointer**
    **sub esp, 8          ; Space for locals a, b**
    **...**
    **mov esp, ebp        ; Cleanup**
    **pop ebp**
    **ret                 ; Return to caller'**

   **NOTE---LEAVE Function CALL TWO Function** 
   **LEAVE{MOV RBP, RSP**
        **POP RBP        }**
---

## ⚠️ Stack Vulnerabilities

|Bug Type|How It Happens|
|---|---|
|**Buffer Overflow**|Overwrites return address or local vars|
|**Stack Smashing**|Inject shellcode via input buffer|
|**ROP (Return-Oriented Programming)**|Hijack control flow via return addr|

---

## 🛡️ Stack Protection Mechanisms

| Defense        | Description                                                    |
| -------------- | -------------------------------------------------------------- |
| **Canaries**   | Special value placed before return address to detect overwrite |
| **ASLR**       | Randomizes memory layout to prevent predictable addresses      |
| **NX Bit**     | Marks stack as non-executable                                  |
| **StackGuard** | Compiler-based stack protection                                |

---

## 🎯 Practical Binary Exploitation Use

- Inject payload into **local buffer**
    
- Overwrite **return address** on stack
    
- Control **EIP/RIP** to redirect execution
    

---

## 📚 Summary

|Component|Role|
|---|---|
|Stack|LIFO memory for function calls|
|Stack Frame|Per-function memory region|
|ESP/RSP|Points to top of stack|
|EBP/RBP|Points to base of current frame|
|Return Address|Where to jump after function|
|Locals/Args|Stored on stack, temporary|

---

## 🖼️ Visual: Stack Function Call Lifecycle

perl


Function call:            ─────────► [push args]
                                     [push return address]
                                     [push ebp → mov ebp, esp]
                                     [allocate local vars]
                                     ...
Function return:          ◄──────── [restore esp, pop ebp]
                                     [ret → jump to return addr]

## 🧠 Why Is Stack Alignment Important?

On **64-bit Linux**, the **System V AMD64 ABI** requires that:

- The stack must be **16-byte aligned** **before a `call` instruction is executed**.
    

If the stack is **misaligned**, the program may:

- Crash (`SIGSEGV`)
    
- Fail to call `system()` or other libc functions correctly
    

---

## ✅ How `ret` Fixes Alignment

A `ret` instruction just **pops the top value from the stack** and **jumps to it**.

If your ROP chain is off by 8 bytes (e.g., not 16-byte aligned), adding a `ret` instruction first:

- Pops 8 bytes (effectively skipping one item on the stack)
    
- Realigns the stack
    
- Then continues your chain safely
    

---

### 📌 Stack Before Alignment (Misaligned):

`rsp → [ addr to system() ]    
`[ "/bin/sh" ]`

Misaligned → crash.

---

### ✅ Add a `ret`:

`rsp → [ address of ret ]      ← You insert this`
 `      [ address of system() ]`
      ` [ "/bin/sh" ]

Now:

- First gadget: `ret` → pops once, realigns
    
- Second gadget: `system("/bin/sh")` works









# 💥 Segmentation Fault (Segfault) — Full Explanation

---

## 🧠 What is a Segmentation Fault?

A **Segmentation Fault** (often called **segfault**) is a runtime error that occurs when a program:

> ❌ **Tries to access memory that it’s not allowed to.**

The OS immediately terminates the program for **violating memory safety**.

📌 In Linux, the error appears as:

java


`Segmentation fault (core dumped)`

---

## 🧩 What Is “Segmentation”?

Memory is divided into **segments** like:

| Segment   | Purpose                        |
| --------- | ------------------------------ |
| `.text`   | Code instructions              |
| `.data`   | Initialized global/static data |
| `.bss`    | Uninitialized global data      |
| **Heap**  | Dynamic memory (`malloc`)      |
| **Stack** | Function calls, local vars     |

When a program accesses a **non-existent or restricted segment**, it triggers a **segfault**.

---

## 🔬 Common Causes of Segfaults

|Cause|Example|
|---|---|
|Dereferencing NULL pointer|`int *x = NULL; *x = 5;`|
|Buffer overflow|`char buf[5]; buf[10] = 'A';`|
|Use-after-free|`free(ptr); *ptr = 1;`|
|Stack overflow|Infinite recursion|
|Invalid pointer arithmetic|`*(arr + 999999)`|
|Writing to read-only memory|`char *str = "hi"; str[0] = 'H';`|
|Uninitialized pointers|`int *x; *x = 10;`|
|Accessing freed memory|`free(p); p[0] = 1;`|

---

## 🧪 C Examples

### ✅ 1. Null Pointer Dereference

c


`int *ptr = NULL; *ptr = 1;  // 💥 Segfault`

### ✅ 2. Buffer Overflow

c


`char buf[4]; strcpy(buf, "ABCDEFG");  // 💥 Writing beyond bounds`

### ✅ 3. Stack Overflow

c


`void boom() {     boom();  // 💥 Infinite recursion }`

---

## 🛠 Debugging with GDB

### ▶ Compile with debug info:

bash


`gcc -g crash.c -o crash`

### 🐞 Run in GDB:

bash


`gdb ./crash run`

### 🔎 Example Output:

cpp


**Program received signal SIGSEGV, Segmentation fault.**
**0x0804842b in main () at crash.c:5**
**5	    *ptr = 5;**

---

## 🧰 How to Prevent Segfaults

|Technique|Description|
|---|---|
|✅ Initialize all pointers|Use `NULL` if not pointing to memory|
|✅ Bounds checking|Avoid writing past buffer length|
|✅ Use Valgrind|Detect use-after-free, invalid reads|
|✅ Use safe string functions|Use `strncpy`, `snprintf`, etc.|
|✅ Don’t use freed memory|Set pointer to `NULL` after `free()`|
|✅ Stack size awareness|Avoid deep recursion or huge arrays|

---

## 📦 Tools for Diagnosis

|Tool|Description|
|---|---|
|`GDB`|Step through code, view backtrace|
|`Valgrind`|Detects invalid reads/writes|
|`ASan`|AddressSanitizer in GCC/Clang|
|`core dump`|Use `ulimit -c unlimited` to analyze|

---

## ⚠️ Exploitation Angle (Binary Exploitation)

In binary exploitation:

- A segfault can mean **memory corruption** (e.g., buffer overflow).
    
- Use it to **leak addresses**, control **return address**, or trigger **ROP chains**.
    

---

## 🧠 Summary

| Concept       | Details                                  |
| ------------- | ---------------------------------------- |
| What is it?   | Invalid memory access                    |
| Common causes | Null deref, overflow, freed memory       |
| Debug tools   | GDB, Valgrind, ASan                      |
| Prevention    | Initialization, bounds check, safe funcs |
| Exploitable?  | Yes — segfaults are key to pwn binaries  |
