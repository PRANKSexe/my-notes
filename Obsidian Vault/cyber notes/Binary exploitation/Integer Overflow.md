# 📚 Integer Overflow: Full Notes

---

## 🧠 1. What is Integer Overflow?

**Integer Overflow** occurs when an arithmetic operation exceeds the maximum (or minimum) value a variable type can store, causing a **wraparound**.

### 🔥 Example (32-bit signed int):

vbnet
`Max:  2,147,483,647 Value: 2,147,483,647 + 1 → -2,147,483,648 (Wraps around to negative)`

---

## 🧪 2. Why Is This Dangerous?

- Can bypass security checks (e.g., size validations).
    
- Leads to **buffer overflows**, **heap corruption**, **information leaks**.
    
- Often used in **heap exploitation**, **length miscalculations**, **memory allocation flaws**.
    

---

## ⚙️ 3. Types of Integer Vulnerabilities

|Type|Description|
|---|---|
|**Integer Overflow**|Value exceeds max limit and wraps|
|**Integer Underflow**|Value goes below minimum and wraps|
|**Signedness Bug**|Signed vs. unsigned comparisons cause logic issues|
|**Truncation**|Large integers cut down when cast to smaller types|

---

## 🧬 4. Integer Types and Limits

| Type       | Range                           |
| ---------- | ------------------------------- |
| `int32_t`  | -2,147,483,648 to 2,147,483,647 |
| `uint32_t` | 0 to 4,294,967,295              |
| `int16_t`  | -32,768 to 32,767               |
| `uint16_t` | 0 to 65,535                     |

Use `limits.h` (C) or `stdint.h` to find limits.

---

## ✅ 5. Vulnerable Code Examples

### C Example:
`#include <stdio.h> #include <stdlib.h>  int main() {     unsigned int len;     scanf("%u", &len);      // Potential overflow: len * sizeof(int)     int *arr = malloc(len * sizeof(int));     if (arr == NULL) {         printf("Memory allocation failed\n");         return 1;     }      // Do something with arr     free(arr); }`

### Problem:

If `len * 4` exceeds `UINT_MAX`, it wraps around and allocates less memory, leading to heap corruption.

---

## 🔥 6. Exploitation Use Cases

### 📌 Use in Exploits:

- **Bypass malloc() checks** with fake small size.
    
- Trigger **buffer overflows** using under-allocated buffers.
    
- Leverage **negative indexing** via signedness bugs.
    
- Use in **ROP / shellcode offsets**.
    

---

## 🧠 7. Signed vs Unsigned Bugs

### C Code Example:

c

`int size; scanf("%d", &size);  if (size < 100) {    char *buf = malloc(size); }`

🧪 Exploit:

- Enter a negative number (e.g., `-1`)
    
- `malloc(-1)` = huge unsigned value → DoS or overflow
    

---

## 🛠️ 8. Detection Techniques

- Look for arithmetic operations: `+`, `-`, `*`, `<<`
    
- Trace allocation code using dynamic input
    
- Use fuzzers (e.g., AFL, libFuzzer) with arithmetic-based mutations
    
- Use static analyzers:
    
    - **C/C++**: Clang’s UBSAN, Coverity, Fortify
        
    - **Python**: `mypy`, `bandit`
        
    - **Java**: `spotbugs`, `FindSecBugs`
        

---

## 🧪 9. Exploitation Tools

|Tool|Purpose|
|---|---|
|AFL / AFL++|Fuzzing input to trigger overflows|
|Valgrind|Memory errors and heap leaks|
|GDB + pwndbg|Debugging and inspecting wrapping|
|angr|Symbolic analysis of integer flaws|

---

## 🧼 10. Prevention Best Practices

✅ Do:

- Use **safe arithmetic libraries** (`SafeInt`, `Checked C`, etc.)
    
- Validate input ranges BEFORE operations
    
- Cast types correctly and safely
    
- Use compiler sanitizers:
    
    - `-fsanitize=undefined` or `-ftrapv` (GCC/Clang)
        

🚫 Don’t:

- Assume multiplication or addition won't overflow
    
- Mix signed/unsigned without checks
    

---

## 📌 11. Real-World Vulnerabilities

|CVE ID|Description|
|---|---|
|CVE-2016-0636|Integer overflow in Java deserialization|
|CVE-2012-0769|Adobe Flash integer overflow → RCE|
|CVE-2015-0286|OpenSSL ASN.1 structure integer overflow|
|CVE-2021-22945|Node.js integer overflow in Buffer.allocUnsafe|

---

## 🧪 12. CTF Challenge Ideas

|Challenge Name|Description|
|---|---|
|HeapMisfit|Exploitable `malloc()` from int overflow|
|SignedMadness|Signed vs unsigned bypass|
|OverflowShop|Integer checks bypass price validator|
|TruncateBug|Truncation overflow when downcasting|

---

## 🧪 13. Test Payloads / Input Ideas

- `0xFFFFFFFF`, `4294967295` (Max uint32)
    
- `-1`, `INT_MIN`, `INT_MAX`
    
- `99999999 * 99999999` (For overflow testing)
    
- Binary fuzzing patterns with arithmetic edge cases
    

---

## 🧪 14. Language-Specific Notes

### 🐍 Python:

- Python 3 ints auto-expand (no overflow), but logic bugs possible.
    

### ☕ Java:

- `int`, `long` overflow silently.
    
- Use `Math.addExact()` to detect overflow.
    

### 🕳️ C/C++:

- Overflow is undefined behavior for signed integers.
    
- Use `__builtin_add_overflow()` in modern GCC/Clang.
    

---

## 🧠 Summary

- Integer overflows are subtle but highly exploitable.
    
- They occur at **boundaries of type limits**.
    
- Combine with buffer or heap logic for powerful attacks.
    
- Use fuzzing + static analysis to find them.
    
- Prevent with safe math, correct type casting, and strict validation.