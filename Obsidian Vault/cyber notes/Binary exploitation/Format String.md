


# 📘 Format String Vulnerability
---

## 🔍 1. Introduction

**Format String Vulnerability** is a type of **memory corruption bug** that arises when **untrusted input is passed as a format string** to a formatted output function (like `printf` in C/C++), allowing attackers to:

- Read arbitrary memory
    
- Write arbitrary memory
    
- Potentially achieve **code execution**
    

---

## 🧠 2. How Format Strings Work

Formatted functions (like `printf`, `sprintf`, etc.) in C use **format specifiers** to control how data is presented.

`printf("Hello %s, your age is %d", name, age);`

Here:

- `%s`: expects a `char*` (string)
    
- `%d`: expects an `int`
    

These format specifiers **consume arguments from the stack** in order.

                      +---------------------------+
                      |     Format String Input   |
                      |   e.g., "Value: %x %x"    |
                      +-------------+-------------+
                                    |
                                    v
                    +-------------------------------+
                    |     printf("Value: %x %x");    |
                    +-------------------------------+
                                    |
                                    v
                +-------------------------------------------+
                |     Format String Parser (in printf)      |
                |  - Looks for format specifiers (%x, %s)   |
                |  - Pulls values from the stack            |
                +----------------+--------------------------+
                                 |
                +-------------------------------+
                |   Stack-based Argument Access  |
                +-------------------------------+
                                 |
             ┌────────────────────────────┐
             │ Stack Layout (32-bit x86)  │
             └────────────────────────────┘
             ▼
`+-------------------------------+`
`| Return Address                |
`+-------------------------------+`
`| Format String Pointer         | ← used by printf
`+-------------------------------+
`| Argument 1 (e.g., int a = 5)  | ← %x accesses this
`+-------------------------------+
`| Argument 2 (e.g., int b = 10) | ← %x accesses this
`+-------------------------------+`
`| ...                           |
`+-------------------------------+`              ▼
`+----------------------------------------+
`|  Output Based on Format Specifiers     |`
`|  E.g., Output: "Value: 5 aabbccdd"     |`
``+----------------------------------------+`








---

## ⚙️ 3. Behind the Scenes – Stack-Based Execution

When you write:
`printf("Value: %x %x");`

Internally:

- The format string is parsed left to right.
    
- Each `%x` consumes 4 bytes (an argument) from the **stack**.
    

If no extra arguments are given, it will still pop from the stack anyway (undefined behavior), printing unintended memory addresses (stack data).

---

## 🚨 4. Vulnerability Example

### ❌ Vulnerable Code:
`char input[100]; scanf("%s", input); printf(input);  // Dangerous`

### Malicious Input:

`AAAA %x %x %x %x`

➡️ Output:
`AAAA deadbeef 80483f4 bffffaaa 41414141`

Shows:

- Stack values
    
- Potential pointer leaks (addresses of libc, etc.)
    

---

## 🔠 5. Format Specifiers – Complete Reference

|Format|Meaning|Example|
|---|---|---|
|`%d`|Signed decimal integer|`42`|
|`%i`|Same as `%d`|`42`|
|`%u`|Unsigned decimal integer|`42`|
|`%x`|Unsigned hexadecimal (lowercase)|`2a`|
|`%X`|Unsigned hexadecimal (uppercase)|`2A`|
|`%o`|Unsigned octal|`52`|
|`%f`|Float (fixed-point)|`3.14`|
|`%e`|Scientific (lowercase)|`3.14e+00`|
|`%E`|Scientific (uppercase)|`3.14E+00`|
|`%g`|Compact float or scientific|`3.14`|
|`%G`|Same as `%g` but uppercase|`3.14`|
|`%c`|Character|`A`|
|`%s`|String|`"hello"`|
|`%p`|Pointer address|`0xdeadbeef`|
|`%n`|Writes number of characters printed so far to a memory location (used in attacks!)||
|`%%`|Literal percent sign|`%`|

---

## 🧨 6. Attack Techniques

### ✅ Information Leak

`printf(user_input);  // "%x %x %x"`

➡️ Leaks stack memory, which may contain:

- Return addresses
    
- Pointers to libc
    
- Environment variables
    
- Passwords or tokens
    

---

### ✅ Reading Arbitrary Memory

`char *ptr = 0xdeadbeef; printf("%s", ptr);  // May crash or print memory`

### ✅ Writing Arbitrary Memory

Using `%n`:
`int target = 0; printf("AAAA%n", &target);`

➡️ Writes `4` (number of characters printed so far) into `target`.

Attackers craft input like:
`\x10\x84\x04\x08 %n`

➡️ Overwrites memory at address `0x08048410`.

---

## 🔬 7. Memory Mechanics

In 32-bit x86 calling conventions:

- Arguments are passed on the **stack**
    
- Format string interprets stack arguments as values
    

### Example:

`printf("A: %x B: %x C: %x");`

➡️ Each `%x` reads 4 bytes from the stack

**Stack Layout Visualization:**
Stack (top ↓)
**| arg3              | ← %x**
**| arg2              | ← %x**
**| arg1              | ← %x**
**| format string ptr |**
**| return address    |**

---

## 🎯 8. Exploit Payload Crafting

To **write 4 bytes to address 0x0804a010**:
`payload = "\x10\xa0\x04\x08"    # Address (little endian)
        `+ "AAAA"
        `+ "%123x"                # Pad to 123 chars
        `+ "%n"                   # Write 123 to address

➡️ Uses `%n` to write character count to memory.

Can be extended using `%hn`, `%hhn` for partial writes.

---

## 📊 9. Diagram – Format String Exploit Lifecycle
┌────────────────────────────┐
│   Untrusted Input (user)   │
└────────────┬───────────────┘
             ▼
  ┌────────────────────────────┐
  │ Used directly in printf()  │
  │ e.g., printf(input);       │
  └────────────┬───────────────┘
               ▼
   ┌──────────────────────────────┐
   │ Stack arguments accessed     │
   │ (%x, %n, %s, etc.)           │
   └────────────┬────────────────┘
                ▼
  ┌────────────────────────────────────┐
  │ Leak info / Write memory / Crash   │
  └────────────────────────────────────┘

---

## 🛡️ 10. Prevention Techniques

|Method|Description|
|---|---|
|✅ Use fixed format strings|`printf("%s", input);`|
|❌ Avoid passing input directly|Never use `printf(input);`|
|🛠 Enable compiler warnings|`-Wall -Wformat -Wformat-security`|
|🧼 Sanitize input|Remove `%`, or limit characters|
|🧪 Use safer functions|`snprintf`, `fgets`, `strncpy`, etc.|
|🔐 Stack protection (canaries)|Detects buffer overflows before return|
|🚫 Disable `%n` (glibc patch)|Use secure libraries that restrict `%n` usage|
|🧰 Use static analyzers|Detect vulnerable format string calls|

---

## 🧰 11. Tools for Detection

| Tool                    | Use Case                    |
| ----------------------- | --------------------------- |
| Flawfinder              | Detect format string issues |
| RATS                    | Source code analysis        |
| Valgrind                | Runtime memory debugging    |
| AddressSanitizer (ASan) | Memory safety               |
| Fortify                 | Compile-time protection     |

---

## 🧪 12. Real-World Exploits

### Format String used in:

- **WU-FTPD** exploit
    
- **snprintf() overflow in BSD**
    
- **CUPS printing system bug**
    
- **Syslog format string vulnerabilities**
    

These bugs often leak **stack, libc, or PIE base addresses** → lead to full **Remote Code Execution (RCE)**.

---

## 🧠 13. Summary Cheat Sheet

|Aspect|Details|
|---|---|
|**Vulnerability**|Format string misuse|
|**Languages Affected**|C, C++, low-level systems|
|**Key Specifiers**|`%x`, `%s`, `%n`, `%p`, `%d`, `%hhn`, `%hn`|
|**Impact**|Info leak, memory write, control hijack|
|**Main Prevention**|Never let user control format string|
|**Tooling**|Flawfinder, ASan, Fortify, compiler flags|
|**Exploit Technique**|Stack memory traversal via format string|
