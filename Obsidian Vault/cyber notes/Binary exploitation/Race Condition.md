# 📚 Race Condition Vulnerabilities in Binary Exploitation – Full Notes

---

## 🧠 What is a Race Condition?

**A race condition occurs when the outcome of a program depends on the non-deterministic timing of threads, processes, or events.**

**In binary exploitation, attackers leverage this timing gap to:**

- **Gain unauthorized access**
    
- **Bypass validation**
    
- **Execute arbitrary code**
    

---

## 🔍 Why Are Race Conditions Dangerous?

- **Occur in security checks, file access, privilege operations.**
    
- **Difficult to detect and reproduce.**
    
- **Can lead to arbitrary file writes, privilege escalation, or information leaks.**
    

---

## 🧪 Types of Race Conditions

|Type|Description|
|---|---|
|**TOCTOU**|_Time-of-Check to Time-of-Use_: File is validated, but changed before use.|
|**Multi-threaded Race**|Two threads access shared memory without synchronization.|
|**Signal-based Race**|Program gets interrupted via `signal()` or `alarm()` at critical points.|
|**Fork/Exec Race**|Race occurs between `fork()` and `exec()` or privileged behavior.|

---

## 📁 1. TOCTOU (Time-of-Check to Time-of-Use)

### 🔥 Description:

File or resource is checked for security, but swapped by attacker before it's used.

### 🧪 C Vulnerable Example:

c
`if (access("/tmp/file", W_OK) == 0) {     int fd = open("/tmp/file", O_WRONLY);     write(fd, "hello", 5); }`

### 🎯 Exploit:

- Replace `/tmp/file` with a symlink to `/etc/passwd` after access() but before open()
    

### ✅ Fix:

- Use `open()` with `O_CREAT | O_EXCL`
    
- Use `faccessat()` with `AT_EMPTY_PATH` + `O_PATH`
    
- Avoid using `access()` before `open()`
    

---

## 🧵 2. Multi-Threaded Race Condition

### 🔥 Description:

Two threads or processes operate on shared variables without atomicity or locks.

### 🧪 C Example:
`int counter = 0;  void *inc(void *arg) {     for (int i = 0; i < 10000; i++)         counter++;  // Unsafe increment }  main() {     pthread_t t1, t2;     pthread_create(&t1, NULL, inc, NULL);     pthread_create(&t2, NULL, inc, NULL);     pthread_join(t1, NULL);     pthread_join(t2, NULL);     printf("%d\n", counter);  // Expect 20000, may get less }`

### ✅ Fix:

- Use `pthread_mutex_t`, `atomic_*` ops, or critical sections.
    

---

## ⏰ 3. Signal-Based Race

### 🔥 Description:

Attacker sends a signal (e.g., `SIGALRM`, `SIGUSR1`) to interrupt program execution and exploit timing.

### 🧪 Example:

c
`volatile int unlocked = 0;  void alarm_handler(int sig) {     unlocked = 1; }  int main() {     signal(SIGALRM, alarm_handler);     alarm(1);      while (!unlocked); // wait      // Assume user is authenticated now     system("cat /etc/shadow"); }`

### ✅ Fix:

- Avoid signals for security logic.
    
- Use state machines or `sigprocmask()` for blocking signals in critical sections.
    

---

## 👥 4. Fork/Exec Race Condition

### 🔥 Description:

A **fork/exec race condition** happens when a privileged program (often SUID root) uses `fork()` to create a child, and then `exec()` to run another binary — **without proper validation or environment sanitization**.

Attackers exploit the time **between `fork()` and `exec()`** to:

- Hijack the child process
    
- Inject code via `LD_PRELOAD`, `PATH`, `PWD`, etc.
    
- Modify file content (TOCTOU-style)
    
- Exploit traceable SUID binaries (e.g., via `ptrace()`).

### 🧪 Vulnerable SUID Example:

c
`int main() {     setuid(0);  // Run as root     pid_t pid = fork();      if (pid == 0) {         // Child process         sleep(1);         execl("/bin/date", "date", NULL);  // Intended binary     } else {         wait(NULL);     } }`

### 🎯 Exploit:

- Use `ptrace()` or LD_PRELOAD tricks
    
- Replace `date` binary if path is not full or protected
    
- If the process is traced, attacker can change its behavior between `fork()` and `exec()`
    

### ✅ Fix:

- Drop privileges before fork()
    
- Use absolute paths
    
- Prevent loading external code (`LD_PRELOAD`, etc.)
    

---

## 🔧 General Exploitation Technique

| Step | Action                                                  |
| ---- | ------------------------------------------------------- |
| 1    | Identify unsynchronized operations                      |
| 2    | Craft two scripts or processes that operate in parallel |
| 3    | One checks the condition (e.g., access)                 |
| 4    | The other swaps file, memory, or signal                 |
| 5    | Observe privilege escalation or bypass                  |
|      |                                                         |

---

## 🛠 Tools for Exploitation

|Tool|Use|
|---|---|
|`inotify`|Watch file changes|
|`strace`|Observe syscall timing|
|`ptrace()`|Hijack or monitor processes|
|`symlink()`|Attack TOCTOU|
|`watch`, `race.py`, bash loops|Trigger high-speed race attacks|

---

## 🧼 Mitigation Strategies

✅ Do:

- Use atomic file operations (open, rename)
    
- Drop privileges before calling untrusted code
    
- Use locks or synchronization primitives
    
- Full path execution with `execve()`
    
- Block signals or delay handling during sensitive logic
    

🚫 Don't:

- Use `access()` or `stat()` before `open()` on world-writable paths
    
- Rely on shared variables across threads without synchronization
    

---

## 🧪 CTF / Lab Ideas

|Name|Concept|Goal|
|---|---|---|
|TOCTOU Flag|Check file, then open|Replace file with symlink|
|SignalSlip|Signal handler controls flow|Send SIGALRM at right time|
|ForkExploit|Fork child with root|Race to replace binary|
|SharedRace|Multi-threaded race|Cause logic error via speed|
